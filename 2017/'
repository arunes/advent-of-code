module StringMap = Map.Make (String)

type program = {
  id : string;
  weight: int;
  children: string list;
}

type program2 = {
  id : string;
  parent_id : string;
  weight: int;
  depth: int;
}


let input = 
  Utils.read_whole_file "./lib/day_07/input.txt" 
  |> String.split_on_char '\n'
  |> List.map (fun row -> 
      let regex = Str.regexp "->" in
      let id_child_pair = Str.split regex row in
      let id_weight_pair = id_child_pair |> List.hd |> String.split_on_char ' ' in
      let id = id_weight_pair |> List.hd in
      let weight = id_weight_pair 
        |> List.tl 
        |> List.hd 
        |> Str.replace_first (Str.regexp "(") "" 
        |> Str.replace_first (Str.regexp ")") "" 
        |> int_of_string in

      if List.length id_child_pair > 1 then
        let children = List.nth id_child_pair 1 
          |> String.split_on_char ',' 
          |> List.map (fun c -> c 
          |> String.trim) in
        { id = id; weight = weight; children = children; }
      else (* no child *)
        { id = id; weight = weight; children = []; }
      )

  

let part1 =
  let rec find_parent id =
    let parent = input |> List.find_opt (fun p -> p.children |> List.exists (fun c -> c = id)) in
    match parent with
    | None -> id
    | Some p -> find_parent p.id
  in
  let first_edge = input |> List.filter (fun r -> r.children = [] ) |> List.hd in
  let parent = find_parent first_edge.id in
  if parent = first_edge.id then "NA" else parent

let part2 = 
  let rec measure_child = function
    | [] -> 0
    | hd :: tl -> 
      let program = input |> List.find (fun p -> p.id = hd) in
      program.weight + measure_child tl
  in

  let get_node_weight id = 
    let program = input |> List.find (fun p -> p.id = id) in
    if program.children = [] then
      program.weight
    else
      program.weight + measure_child program.children
  in

  let rec fill parent_id id depth lst =
    let self = input |> List.find (fun p -> p.id = id) in
    let weight = get_node_weight id in

    let rec for_children l = function
      | [] -> l
      | hd :: tl ->
        let child_weight = get_node_weight hd in
        for_children ({
          id=hd;
          parent_id=id;
          weight=child_weight;
          depth=depth+1
        } :: (fill id hd (depth + 1) l)) tl
    in

    for_children ({ id=id;parent_id=parent_id;weight=weight;depth=depth; } :: lst) self.children
    
  in

  let full_list = fill "" part1 0 [] in
  let max_depth = full_list |> List.map snd |> List.map fst |> List.fold_left max 0 in
  let() = Format.printf "MAX DEPTH=%d\n" max_depth in

  let log_line = full_list
      |> List.map (fun e -> 
          let props = snd e in
          fst(e) ^ "=" ^ (string_of_int (snd props)) ^ ", DEPTH=" ^ (string_of_int (fst props))
          ) 
      |> String.concat "\n" in

  log_line
